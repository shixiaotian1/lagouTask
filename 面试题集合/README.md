### 项目说明

1. spring boot读取配置文件的优先级？

   答：spring boot会优先扫描工程目录下的./config/文件夹夹，然后是工程根目录；

   再是classpath:/config/，然后classpatch；高优先级的会覆盖低优先级的，并且所有配置文件都会加载，会形成互补配置；可以通过指定配置来改变读取配置，spring.config.location=application.yml；

2. 说说双重检查锁？

   答：双重检查锁，是在多线程情况下单例模式的一种升级；常规单例模式，无法保证并发的情况下，对象绝对单例；所以需要通过加锁来实现，就是首先判断对象是否为空，为空就加锁，加锁之后再次判断对象是否为空，为空则去创建对象；但需要注意的是，需要考虑到指重排序问题，故需要对返回的属性，进行volatile修饰，来避免指令重排序；

3. 知道redis事物嘛，命令是什么？

   答：MULTI开启一个事物，EXEC提交一个事物，DISCARD取消事物；redis单个命令是原子性的，但是redis没有在事物上增加原子性的机制，单个命令的错误，不会影响到队列中redis命令的执行和回滚，其实redis事物更像是一个打包操作，把命令批量执行；

4. synchronized和ReentrantLock它们有什么区别？

   答：synchronized和ReentrantLock都提供了锁的功能，具备互斥性和不可见性，在JDK1.5中synchronized性能原低于ReentrantLock，但在JDK1.6之后，synchronized性能略低于ReentrantLock；他们区别如下：

   - synchronized是JVM隐式实现的，而ReentrantLock是Java语言提供的API；
   - ReentrantLock可设置为公平锁，而synchronized却不行；
   - ReentrantLock只能修饰代码块，而synchronized可以修饰方法、修饰代码块等；
   - ReentrantLock需要手动加锁和释放所，如果忘记释放所，则会造成资源被永久占用，而synchronized无需手动释放锁；
   - ReentrantLock可以知道是否成功获得了锁，而synchronized却不行；

5. synchronized的实现原理能描述下嘛？

   答：synchronized属于独占式悲观锁，是通过JVM隐式实现的，synchronized只允许同一时刻只有一个线程操作资源。在Java中每个对象都隐式的包含了一个monitor（监视器）对象，加锁的过程其实就是竞争monitor的过程，当线程进入字节码monitorenter指令之后，线程持有monitor对象，执行monitorexit时释放monitor对象，当其他线程没有拿到monitor对象时，则需要阻塞等待获取该对象。

6. ReentrantLock是如何实现的？

   答：ReentrantLock是Lock的默认实现方式之一，它是基于AQS的实现，是在它的内部有一个state的状态字段用于表示锁是否占用，如果是0则表示锁未被占用，此时线程就可以把state改为1，并成功获得锁，而未获得锁的线程只能排队去等待获取锁资源；

7. 说说公平锁和非公平锁有什么区别？

   答：公平锁顾名思义，线程需要按照请求的顺序来获得锁；而非公平锁则允许“插队”的情况存在；所谓的“插队”，是指线程在发送请求的同时该锁状态恰好变成了可用，那么此线程就可以跳过队列中所有排队的线程直接拥有该锁；而公平锁由于有挂起和恢复所以存在一定的开销，因此性能不如非公平锁，所以ReentrantLock和synchronized默认都是非公平锁实现方式。

8. JDK1.6对锁做了哪些优化知道不？

   - 自适应自旋锁，自旋是让线程执行一个忙循环（自旋），超过一定次数仍然没有成功获取锁，则线程挂起；自适应自旋锁，在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在进行中，那么虚拟机就会认为这次自旋很有可能会再次成功，因此将允许它自旋等待更长的时间；反之自旋很少成功过的，在以后获取锁时将可能省略掉自旋过程，以避免CPU浪费；
   - 锁粗化，JVM检测一串操作都对同一对象加锁，会把锁同步的范围粗化到整个操作序列外部；
   - 锁消除，JVM在JIT编译运行时，通过对运行上下文的扫描，去除不可能存在共享数据竞争的锁；判断依据逃逸分析，判断堆上的数据不会被其它线程访问，那么把它们当做栈上的数据对待，认为它们是私有的，无需加锁；
   - 轻量级锁，JDK1.6引入，绝大部分锁，在整个生命周期内不会存在竞争，没有竞争，使用CAS消除互斥量；
   - 偏向锁，在整个生命周期内不存在竞争，并且总由同一个线程多次获得，这个锁偏向第一个获取它的线程，如果接下来的执行中，该锁没有被其它线程获取，则持有偏向锁的线程永远不需再进行同步；
   - 锁升级，又称为锁膨胀，synchronized刚开始为偏向锁，随着竞争的越来越激烈，会升级为轻量级锁和重量级锁；如果大多数锁被不同的线程所争抢就不建议使用偏向锁；-XX:-UseBiasedLocking来禁用偏向锁以提高性能；