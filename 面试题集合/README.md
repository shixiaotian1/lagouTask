### 补充面试题

1. **spring boot读取配置文件的优先级？**

   答：spring boot会优先扫描工程目录下的./config/文件夹夹，然后是工程根目录；

   再是classpath:/config/，然后classpatch；高优先级的会覆盖低优先级的，并且所有配置文件都会加载，会形成互补配置；可以通过指定配置来改变读取配置，spring.config.location=application.yml；

2. **说说双重检查锁？**

   答：双重检查锁，是在多线程情况下单例模式的一种升级；常规单例模式，无法保证并发的情况下，对象绝对单例；所以需要通过加锁来实现，就是首先判断对象是否为空，为空就加锁，加锁之后再次判断对象是否为空，为空则去创建对象；但需要注意的是，需要考虑到指重排序问题，故需要对返回的属性，进行volatile修饰，来避免指令重排序；

3. **知道redis事物嘛，命令是什么？**

   答：MULTI开启一个事物，EXEC提交一个事物，DISCARD取消事物；redis单个命令是原子性的，但是redis没有在事物上增加原子性的机制，单个命令的错误，不会影响到队列中redis命令的执行和回滚，其实redis事物更像是一个打包操作，把命令批量执行；

4. **synchronized和ReentrantLock它们有什么区别？**

   答：synchronized和ReentrantLock都提供了锁的功能，具备互斥性和不可见性，在JDK1.5中synchronized性能原低于ReentrantLock，但在JDK1.6之后，synchronized性能略低于ReentrantLock；他们区别如下：

   - synchronized是JVM隐式实现的，而ReentrantLock是Java语言提供的API；
   - ReentrantLock可设置为公平锁，而synchronized却不行；
   - ReentrantLock只能修饰代码块，而synchronized可以修饰方法、修饰代码块等；
   - ReentrantLock需要手动加锁和释放所，如果忘记释放所，则会造成资源被永久占用，而synchronized无需手动释放锁；
   - ReentrantLock可以知道是否成功获得了锁，而synchronized却不行；

5. **synchronized的实现原理能描述下嘛？**

   答：synchronized属于独占式悲观锁，是通过JVM隐式实现的，synchronized只允许同一时刻只有一个线程操作资源。在Java中每个对象都隐式的包含了一个monitor（监视器）对象，加锁的过程其实就是竞争monitor的过程，当线程进入字节码monitorenter指令之后，线程持有monitor对象，执行monitorexit时释放monitor对象，当其他线程没有拿到monitor对象时，则需要阻塞等待获取该对象。

6. **ReentrantLock是如何实现的？**

   答：ReentrantLock是Lock的默认实现方式之一，它是基于AQS的实现，是在它的内部有一个state的状态字段用于表示锁是否占用，如果是0则表示锁未被占用，此时线程就可以把state改为1，并成功获得锁，而未获得锁的线程只能排队去等待获取锁资源；

7. **说说公平锁和非公平锁有什么区别？**

   答：公平锁顾名思义，线程需要按照请求的顺序来获得锁；而非公平锁则允许“插队”的情况存在；所谓的“插队”，是指线程在发送请求的同时该锁状态恰好变成了可用，那么此线程就可以跳过队列中所有排队的线程直接拥有该锁；而公平锁由于有挂起和恢复所以存在一定的开销，因此性能不如非公平锁，所以ReentrantLock和synchronized默认都是非公平锁实现方式。

8. **JDK1.6对锁做了哪些优化知道不？**

   - 自适应自旋锁，自旋是让线程执行一个忙循环（自旋），超过一定次数仍然没有成功获取锁，则线程挂起；自适应自旋锁，在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在进行中，那么虚拟机就会认为这次自旋很有可能会再次成功，因此将允许它自旋等待更长的时间；反之自旋很少成功过的，在以后获取锁时将可能省略掉自旋过程，以避免CPU浪费；
   - 锁粗化，JVM检测一串操作都对同一对象加锁，会把锁同步的范围粗化到整个操作序列外部；
   - 锁消除，JVM在JIT编译运行时，通过对运行上下文的扫描，去除不可能存在共享数据竞争的锁；判断依据逃逸分析，判断堆上的数据不会被其它线程访问，那么把它们当做栈上的数据对待，认为它们是私有的，无需加锁；
   - 轻量级锁，JDK1.6引入，绝大部分锁，在整个生命周期内不会存在竞争，没有竞争，使用CAS消除互斥量；
   - 偏向锁，在整个生命周期内不存在竞争，并且总由同一个线程多次获得，这个锁偏向第一个获取它的线程，如果接下来的执行中，该锁没有被其它线程获取，则持有偏向锁的线程永远不需再进行同步；
   - 锁升级，又称为锁膨胀，synchronized刚开始为偏向锁，随着竞争的越来越激烈，会升级为轻量级锁和重量级锁；如果大多数锁被不同的线程所争抢就不建议使用偏向锁；-XX:-UseBiasedLocking来禁用偏向锁以提高性能；

### JVM虚拟机

1. **JVM内存划分几个区域，分别干什么的？**

   - 方法区，存放要加载类的信息（类名和修饰符）、类中的静态变量、final修饰的常量、方法信息，方法区是全局共享的，对应的是永久代，很少执行GC；
   - 堆，主要存放对象实例及数组，所有new出来的对象在此分配，所有线程共享，在虚拟机启动时创建；
   - 本地方法栈和虚拟机栈，线程私有的，局部变量会存放到站中；
   - 程序计数器，很小的区域，线程私有的，存放当前线程行号指示器；

2. **讲讲Java内存模型(JMM)**

   答：Java Memory model，是一种符合内存模型的规范，屏蔽了各种硬件和操作系统的访问差异，保证了Java程序在各种平台下对内存访问都能保证效果一致的机制及规范。它屏蔽了各种硬件和操作系统的访问差异，不像C语音那样可以直接访问物理内存，相对安全；它主要是用于解决由于多线程通过共享内存进行通信时，存在本地内存数据不一致、编译器对代码指令重排序的问题。可以保证场景的原子性、可见性和有序性。

3. **JVM默认栈和堆内存大小是多少？设置参数是什么？**

   答：-Xms初始堆大小，-Xmx最大堆空间，-Xss栈大小，-Xmn设置新生代大小，-XX设置新生代空间比例。

4. **常用的垃圾回收器有哪些，你用哪些？**

   答：年轻代，Serial(复制算法)，ParNew(标记整理算法)，Paraller Scanvenge(停止复制算法)；

   老年代，CMS(标记清除算法)，SerialOld(MSC)(标记整理算法)，ParallerOld(停止复制算法)；

   G1；

5. **垃圾收集算法有哪些，都有什么优缺点？**

   答：标记清除算法，首先标记出需要回收的对象，之后统一回收所标记的对象，容易出现碎片区域。

   复制算法，将内存划分为两个区域，每次只使用其中一块；执行回收时将存活的对象复制到另一块区域，容易造成内存浪费。

   标记整理算法，类似与标记清除，只不过在清除标记的对象后，将存活的对象进行整理，合并到一端。

6. **java采用的什么样一种垃圾收集方式？**

   答：分代收集，将内存区划分为新生代、老年代。新生代内存按照8:1:1的比例又划分为一个End区和两个survivor区，新生代采用复制算法，老年代采用标记清除和标记整理算法；

7. **有哪几种GC类型，分别做了什么？**

   - Minor GC，发生在新生代，新生代对象大多朝生夕灭，所以Minor GC十分频繁，回收速度也很快。
   - Major GC，发生在老年代，当出现Major GC时一般也会伴随至少一次的Minor GC。
   - Full GC，清理整个堆空间，包括年轻代和老年代。

8. **产生Full GC可能的原因？**

   答：老年代被写满、持久代被写满、显示的调用System.gc()被显示的调用、上一次GC之后Heap的各域分配策略动态变化。

9. **java用了哪些垃圾回收算法？**

   - 引用计数法，每个对象添加一个引用计数器，有地方引用时这个对象时，计数+1；当计数为0时，表示该对象不会再被使用。缺点无法识别相互引用的对象。
   - 可达性分析算法，通过一系列被称为GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径被称为引用链；当一个对象到GC Roots没有任何引用链相连时，则代表此对象是不可达的；

10. **JVM虚拟机性能监控命令有哪些，有哪些常用工具？**

    答：jps查看虚拟机进程、jstat虚拟机统计信息、jinfo查看虚拟机各项参数、jmap生成堆转存储快照；JConsole和VisualVM可视化工具。

11. **简单说说Class文件结构和规范？**

    答：魔数，开头的四个字节确定这个文件为一个可以被虚拟机接受的Class文件；

    文件版本号；常量池；访问标志；类索引、父类索引和接口索引；字段表集合；方法表集合；属性表集合；

12. **JVM虚拟机类加载过程？**

    答：加载、验证、准备、解析、初始化（加载自己的java类）、使用和卸载。

13. **知道有哪些类加载器嘛，分别对应的加载什么东西？类加载过程遵循什么原则？**

    - 启动类加载器（Bootstrap ClassLoader），是虚拟机的一部分，负责加载/lib目录中的类，所有java.*开头的均是被该类加载，无法被Java程序直接引用。*
    - 扩展类加载器（Extension ClassLoader），负责加载/lib/ext目录中的类，javax.*开头的类，可以直接使用扩展类加载器。
    - 应用程序类加载器（Application ClassLoader），负责加载用户路径所指定的类，如果没有自定义类加载器，这个将是默认类加载器。

    类加载遵循双亲委派模型。

14. **知道如何破坏双亲委派模型吗？有哪些应用场景？**

    答：Java提供了一个上下文类加载器（Thread Context ClassLoader），这个类加载器可以使得父类加载器请求子类加载器完成加载动作，从而打破了双亲委派模型；常见的场景有Tomcat和JDBC加载驱动的时候。

15. **你知道如何优化JVM吗？有哪些方式？**

    答：可以从内存大小设置和回收器的选择这两个方面来做；较小堆的设置，会出现碎片的问题，如果碎片空间不够存放对象，那么会进行标记整理，而造成停顿；

    1. 新生代大小的选择，

       响应时间优先的选择，尽可能大，这种情况下新生代收集发生的频率是最小的，同时减少了到达老年代的对象。

       吞吐量优先的应用，尽可能设置大，可能达到GB的程度，垃圾收集器选择并行进行的，一般适用8GB以上的应用。

    2. 老年代的选择，

       响应时间优先，内存设置需参考并发垃圾收集信息、持久带并发收集次数、传统GC信息、花在新生代和老年代回收的时间比例；

       吞吐量优先的应用，一般吞吐量优先的应用会选择一个很大的新生代和一个很小的老年代，尽可能的回收掉大部分短期对象，减少中期对象，而老年代用来存放长期存活对象；

### 数据库（MySql）

1. **你常用的数据库引擎有哪些，有哪些优劣点？**

   - InnoDB，mysql默认的存储引擎，支持事务；
   - MyISAM，mysql5.5之前默认的存储引擎，但是不支持事务；
   - Archive，为大量很少引用的历史、归档、或安全审计信息存储或检索提供了完美的解决方案；
   - Merge，将所有数据保存在内存中，可以达到快速查找和访问的目的；

2. **了解索引吗？索引类型有哪些？**

   - Normal普通索引；
   - Unique唯一索引，不允许重复；
   - Full Text全文索引，搜索长文本；
   - Spatial空间索引，对地理空间位置数据类型字段简建立的索引；

3. **知道聚集索引吗？聚集索引和非聚集索引有什么区别？**

   答：聚集索引的数据和索引是分开，称为非聚集索引；同理数据和索引在一起，称为聚集索引；在MyIASM引擎当中，主键索引和辅助索引的数据和索引都是分开的，所以都是非聚集索引；在InnoDB引擎当中，主键索引的索引和数据聚集在一起，是聚集索引；但辅助索引的索引叶子节点存放的是主键的值，故为非聚集索引；所以InnoDB引擎一定要设置主键，即使不设置，数据库也会默认设置一个隐式主键；

4. **说说索引的实现原理是什么，有什么好处？**

   答：InnoDB存储引擎索引的实现采用的是B+Tree的结构实现；B+Tree的特点是只有叶子节点才会存放数据，非叶子节点只存放索引值；B+Tree更加矮，IO次数更加少；而且即使数据不同查询也会走到叶子节点，所以查询更加稳定；同样B+Tree也更加擅长范围查找；

5. **怎么查看SQL是否使用到了索引，各个参数分别代表什么？**

   答：explain查看执行计划，其中有个type字段，system>const>eq_ref>ref>range>index>ALL；

6. **说说索引建立规则？**

   答：某个字段取值范围很广，很少有重复的是最适合建立索引的；通过SHOW INDEX FROM 表名；语句来查看表中存在的索引，其中Cardinality值越大越适合做索引；

7. **说说数据库的事务，生产环境你一般选择哪个级别的？**

   - A(atomicity)原子性，C(consistency)一致性，I(isolation)隔离性，D(durability)持久性；
   - 读未提交、读已提交、可重复度和串行化；
   - 生产环境一版使用读已提交，mysql默认是可重复度；

8. **做过数据库分区嘛？是不是分区之后性能就会提升？要遵循什么原则吗？**

   - OLTP（在线事务处理），如电子商务、网络游戏和Blog等的应用，大部分情况下通过索引返回几条记录即可，一般仅需要2~3次IO，不需要分区的帮助，并且如果设计的不好，很容易造成性能问题；
   - OLAP（在线分析处理），如数据仓库、日志报表等应用，每次都会获取范围内大量数据，根据范围分区的话，会有显著的性能提升；

9. **说说数据库如何优化？**

   - 设置缓冲池大小，通过内存的速度来弥补磁盘速度的不足，innodb_buffer_pool_size参数；
   - 开启自适应哈希，InnoDB会检测表上各个索引是否可以通过建立哈希索引来提升查询效率，innodb_adaptive_hash_inde参数；
   - 开启异步IO，开启后InnoDB可以用异步的方式处理磁盘操作innodb_use_native_aio；
   - MRR优化，减少磁盘随机访问，转变成顺序化访问，mrr设置为on，mrr_cost_based设为off来启用MRR优化；

10. **知道慢查询吗？**

    答：slow_query_log设置为on开启；long_query_time参数设置时间；slow_query_log_file参数查看慢sql日志文件位置；

11. **你知道in和exists的区别吗？**

    答：in会把外表和内表做hash join ，而exists是对主表做loop循环，每次loop循环再对内表进行查询。在使用not in和not exists的时候，not in相当于不等于，不会使用索引，而not exists仍然是做loop循环，会进行索引查询，所以效率会高；

12. **数据库高可用的架构是什么样的？**

    答：做读写分离和数据库主从；

13. **那如何保证主从数据库一致呢？**

    - 半同步复制，主库发生修改操作，等辅库修改完成并通知主库，才做操作成功；
    - 数据库中间件，如Sharding-JDBC，所有请求都走中间件；
    - 自己写缓存记录，当数据库发生变更操作时，记录到缓存里，在一定时间内，所有的请求都走主库读取数据，当所有的库都完成同步时，删除缓存；继续分库查询；

### Java基础

1. **你经常用到哪些数据结构？分别有什么区别？**

   答：Map（键值对，散列表），List（数组，有序可重复），set（无序，不可重复）；

2. **说说ArraryList和LinkedList的区别？**

   - ArraryList内部是数组实现的，是一块连续的内存区域，可以通过数组下标查找元素，增加和删除会造成位置移动；
   - LinkedList是链表的形式，不连续的区域，每个元素都会保存下一个元素的坐标位置，新增和删除比较快，查找需要遍历链表；

3. **详细讲解一下HashMap？**

   - HashMap实现了Map接口，继承了AbstractMap；
   - 默认容量是16，加载因子是0.75；
   - 数据是一种散链表，key和value都可以存放null；
   - 存储的时候，会先判断key是否为null，为null的话直接调用putForNullKey方法；
   - 若不为null的时候，则计算key 的hash值，然后根据hash值来确定存储table的位置；
   - 如果该位置有元素，则比较key是否相等，相等则替换元素；
   - 不同则保存在链头；当元素数量大于容量*加载因子，会进行扩容操作；

4. **JDK1.8对HashMap做了哪些优化，为什么要这么做？**

   - 在JDK1.7中HashMap是以数组加链表的新式组成的；

     在JD1.8之后，当链表大于8，链表结构会转换成红黑树结构；

   - 在JDK1.7的时候，链表插入方式，首部倒叙插入；

     JDK1.8的时候改成了尾部正序；

   - 多线程的时候改善死循环的发生；但仍然不能根本解决问题，Sun公司建议在多线程的时候使用ConcurrentHashMap替代；

5. **谈谈HashMap，是如何解决哈希冲突的？**

   答：HashMap采用的是链表法，就是将存在哈希冲突的数据，以一个链表的形式存放在存在冲突的槽位，形成的链表是单向链表；

6. **HashMap扩容的时候，一定会移动元素吗？**

   答：JDK1.7的时候会重新计算每个元素的哈希值，元素会有位移；

   ​		JDK1.8的时候，会通过高位运算，来确定元素是否需要移动；

7. **知道WeakHashMap吗？和HashMap有什么区别？**

   答：WeakHashMap和HashMap一样，只不过WeakHashMap的键是弱键，当这个键不再被使用的时候，会被GC回收掉；

8. **那你知道WeakHashMap有哪些使用场景吗？它的弱键一定会被回收吗？**

   答：一般用做缓存，我记得Tomcat源码里，实现缓存的时候用到了WeakHashMap；在缓存系统中用WeakHashMap可以避免内存泄漏；但需要注意，它的key只有WeakHashMap本身在用，对外没有对该key的强引用的时候，才会被GC回收；所以一般用做二级缓存或低频缓存，不能用做主缓存；

9. **说说JDK和JRE的区别？**

   答：JRE是Java运行时环境，JDK是Java运行环境和开发环境；JDK包含了JRE；

10. **==和equals()的区别？**

    答：==是比较基本类型是否相等，equals()是比较引用对象指向地址是否相等；String重写了equals方法；

11. **String是如何实现的？它有哪些重要的方法？**

    - String内部实际存储结构是char数组；
    - 内部包含多构造方法，其中有new String(StringBuffer);new String(StringBuilder);
    - equals()比较相等方法；compareTo()比较方法；indexOf()首次出现下标的位置；lastIndexOf()最后出现下标位置；contains()包含某个字符串；toLowerCase()转换成小写；toUpperCase()转换成大写；length()长度；trim()去掉首尾空格；replace()替换字符串；split()切割字符串成数组；join()将字符串数组转换成字符串；

12. **compareTo()和equals()方法有什么区别？**

    答：equals可以接收Object类型的方法；而compareTo只能接收String类型的；

    compareTo返回值为int，两个字符串相等的个数；equals返回值为boolean；

13. **你知道String是用final修饰的吗？有什么好处？**

    - 安全，Java语言之父说，在调用一些系统操作指令之前，一般会做一系列的安全校验，如果是可变类的话，可能会在你校验之后，它的内部值又被改变了，这样很可能会导致严重的系统崩溃问题；
    - 高效，字符串不可变时，我们可以实现字符串常量池，字符串常量池可以缓存字符串，提高程序运行效率；

14. **String s1 = "Java"和String s2 = new String("Java")有什么区别吗？**

    答：存储区域不同，直接赋值会查询常量池中是否存在，存在直接引用，不存在则在常量池中创建后，再引用；new会直接在堆中创建一个变量，调用intern方法才会把字符串保存到常量池中；

15. **parseInt和valueOf方法的区别吗？**

    答：返回值不同，parseInt返回基本类型，valueOf返回包装类型对象；valueOf实际上是调用了parseInt方法；

16. **你知道JVM对字符串做了哪些优化吗？**

    答：编译器会对连续拼接字符串，视为同一个；例如，”Ja” + “va”；等同于”Java”；

17. **反射用到了哪些接口和类？**

    答：类，Class、Constructor、Field、Method；

    接口，Serializable、GenericDeclaration、Type、AnnotationElement；

18. **反射可以获取private的成员的值吗？**

    答：可以，通过设置setAccessible(true)进行暴力反射，解除权限；

19. **说说过滤器（Filter）和拦截器（Interceptor）的区别？**

    - 过滤器是基于函数回调，依赖于servlet；

      拦截器是利用Java反射，面向切面编程，依赖框架；

    - 过滤器在拦截器之前执行；

    - 过滤器只能在servlet前后执行，一般做登录、参数校验、编码等功能；

    - 拦截器可以在方法前后，异常前后执行，灵活性更大；

20. **Object类有哪些方法？**

    答：clone，保护的方法，需要实现Cloneable接口才可以使用，可以实现对象的浅复制；

    getClass，toString，finalize，equals，hashCode，wait，notify，notifyAll；

21. **知道BIO、NIO和AIO的区别吗？**

    - BIO是同步阻塞的；
    - NIO是同步非阻塞；
    - AIO是异步非阻塞；

22. **线程wait()和Sleep()方法有什么区别？**

    - wait，释放资源，并释放锁；是Object的方法，进入等待锁定池，notify()唤醒线程池中的一个线程（任意），notifyAll()唤醒线程池中所有线程；
    - Sleep()，释放资源，不释放锁；是Thread本身的静态方法，暂停线程但监控状态仍然会保持，在时间到时自动唤醒，或interrupt()方法；

23. **知道volatile关键字有什么用吗？**

    答：volatile用于声明简单变量。被Volatile声明的变量，系统每次使用它时都会直接从响应内存中提取，而不会利用缓存；在使用Volatile修饰的变量后，全部线程不论任何时候，看到的变量值都是最新的。但Volatile不能保证原子性和互斥性，但可以保证可见性和有序性；相对于Synchronized相比是一种轻量级的同步策略；

    - 状态标识，用Volatile修饰状态变量，线程A执行循环，线程B修改变量状态；线程A收到修改停止循环；
    - 独立观察，Volatile修饰变量，线程A执行修改变量内容，线程B执行时，可获取最新变量内容；

24. **你知道线程有哪些通讯方式吗？**

    - 使用一个共享变量，如Synchronized、Lock和volatile修饰变量；

    - 流的方式，PipedInputStream、PipedOutStream；

    - 利用BlockingQueue，有四个实现，ArrayBlockingQueue数组阻塞队列、LinkedBlockingQueue链阻塞队列；

      PriorityBlockingQueue排序队列、SynchronizedQ只能容纳单个元素；

      DelayQueue延迟队列；

25. **创建线程的方式有哪几种？**

    - 继承Thread类，重写run()方法；
    - 实现Runnable接口，重写run()方法；
    - 实现Callable接口，重写call()方法；

26. **那你知道runable和callable有什么区别吗？**

    答：callable有返回值，而runnabale没有；call()可以抛出异常，run()不行；

27. **线程有哪些状态，是如何切换的？**

    - 使用getStatus()方法，会返回线程状态；
    - New，线程创建之后，启动之前；
    - Runnable，当调用start方法后，线程进入可以被执行的状态；
    - Blocked，线程进入临界区，由调度区选一个来执行；
    - waiting，等待状态，当调用了wait、join方法后会进入这个状态，notify唤醒；
    - Timed_Waiting，也是等待状态，只不过有个计时器在里面，常见的sleep进入，到时间会自动唤醒；
    - Terminated，终结状态，线程执行完成会进入当前状态；